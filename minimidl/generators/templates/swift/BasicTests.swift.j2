// Generated by MinimIDL - Swift Unit Tests
// DO NOT EDIT - This file was automatically generated

import XCTest
@testable import {{ namespace.name }}

final class {{ namespace.name }}Tests: XCTestCase {
    
    override func setUp() {
        super.setUp()
        // Clear any previous errors
        clearError()
    }
    
    {% for interface in namespace.interfaces %}
    func test{{ interface.name | swift_class_name }}Creation() throws {
        let obj = {{ interface.name | swift_class_name }}()
        XCTAssertNotNil(obj)
        
        // Check for creation errors
        XCTAssertNil(getLastError(), "Error creating {{ interface.name }}: \(getLastError() ?? "")")
    }
    
    {% for property in interface.properties %}
    {% if property.type | is_primitive and property.writable %}
    func test{{ interface.name | swift_class_name }}{{ property.name | capitalize }}Property() throws {
        let obj = {{ interface.name | swift_class_name }}()
        
        // Test getter
        let initialValue = obj.{{ property.name }}
        XCTAssertNotNil(initialValue)
        
        // Test setter
        {% if property.type.name == "bool" %}
        let newValue: {{ property.type | swift_type }} = !initialValue
        {% elif property.type.name in ["int32_t", "int64_t"] %}
        let newValue: {{ property.type | swift_type }} = initialValue + 1
        {% elif property.type.name in ["float", "double"] %}
        let newValue: {{ property.type | swift_type }} = initialValue + 1.0
        {% else %}
        let newValue = initialValue  // Default case
        {% endif %}
        obj.{{ property.name }} = newValue
        XCTAssertEqual(obj.{{ property.name }}, newValue)
    }
    {% elif property.type | is_string and property.writable %}
    func test{{ interface.name | swift_class_name }}{{ property.name | capitalize }}Property() throws {
        let obj = {{ interface.name | swift_class_name }}()
        
        // Test getter
        let initialValue = obj.{{ property.name }}
        XCTAssertNotNil(initialValue)
        
        // Test setter
        let testString = "Test String 123"
        obj.{{ property.name }} = testString
        XCTAssertEqual(obj.{{ property.name }}, testString)
        
        // Test empty string
        obj.{{ property.name }} = ""
        XCTAssertEqual(obj.{{ property.name }}, "")
    }
    {% elif property.type | is_array and property.writable %}
    func test{{ interface.name | swift_class_name }}{{ property.name | capitalize }}Property() throws {
        let obj = {{ interface.name | swift_class_name }}()
        
        // Test initial state
        let initialArray = obj.{{ property.name }}
        XCTAssertNotNil(initialArray)
        
        {% if property.type.element_type | is_string %}
        // Test setter with string array
        let testArray = ["item1", "item2", "item3"]
        obj.{{ property.name }} = testArray
        XCTAssertEqual(obj.{{ property.name }}, testArray)
        
        // Test empty array
        obj.{{ property.name }} = []
        XCTAssertEqual(obj.{{ property.name }}.count, 0)
        {% endif %}
    }
    {% endif %}
    {% endfor %}
    
    {% for method in interface.methods %}
    {% if method.parameters | length == 0 %}
    func test{{ interface.name | swift_class_name }}{{ method.name | capitalize }}Method() throws {
        let obj = {{ interface.name | swift_class_name }}()
        
        {% if method.return_type.name == "void" %}
        // Test void method
        obj.{{ method.name }}()
        XCTAssertNil(getLastError(), "Error calling {{ method.name }}: \(getLastError() ?? "")")
        {% elif method.return_type | is_primitive or method.return_type | is_enum %}
        // Test method with return value
        let result = obj.{{ method.name }}()
        XCTAssertNotNil(result)
        {% elif method.return_type | is_string %}
        // Test method returning string
        let result = obj.{{ method.name }}()
        XCTAssertNotNil(result)
        {% endif %}
    }
    {% endif %}
    {% endfor %}
    {% endfor %}
    
    {% if namespace.enums %}
    // MARK: - Enum Tests
    
    {% for enum in namespace.enums %}
    func test{{ enum.name }}Enum() throws {
        // Test all enum cases
        {% for value in enum.values %}
        XCTAssertEqual({{ enum.name }}.{{ value.name | lower }}.rawValue, {{ value.value | render_expression }})
        {% endfor %}
        
        // Test CaseIterable
        XCTAssertEqual({{ enum.name }}.allCases.count, {{ enum.values | length }})
        
        // Test C value conversion
        {% if enum.values %}
        let testCase = {{ enum.name }}.{{ enum.values[0].name | lower }}
        let cValue = testCase.cValue
        let reconstructed = {{ enum.name }}(cValue: cValue)
        XCTAssertEqual(testCase, reconstructed)
        {% endif %}
    }
    {% endfor %}
    {% endif %}
    
    // MARK: - Error Handling Tests
    
    func testErrorHandling() throws {
        // Clear any existing errors
        clearError()
        XCTAssertNil(getLastError())
        
        // Note: Actual error testing would require triggering error conditions
        // in the C API, which depends on the implementation
    }
}