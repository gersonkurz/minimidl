// Generated by MinimIDL - C Wrapper Implementation
// DO NOT EDIT - This file was automatically generated

#include "{{ namespace.name.lower() }}_wrapper.h"
#include "{{ namespace.name }}.hpp"
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <memory>
#include <cstring>
#include <thread>
#include <atomic>

// Core interfaces
class IRefCounted {
public:
    virtual ~IRefCounted() = default;
    virtual void AddRef() = 0;
    virtual void Release() = 0;
};

class IDynamicString : public IRefCounted {
public:
    virtual const char* GetValue() const = 0;
    virtual void SetValue(const char* value) = 0;
    virtual size_t GetLength() const = 0;
};

// Reference counting template
template <typename T>
class RefCounted : public T {
public:
    RefCounted() : m_refCount{1} {}
    
    void AddRef() override final {
        ++m_refCount;
    }
    
    void Release() override final {
        if (--m_refCount == 0) {
            delete this;
        }
    }

private:
    mutable std::atomic<int32_t> m_refCount;
};

// Concrete string implementation
class DynamicString : public RefCounted<IDynamicString> {
private:
    std::string m_value;
    
public:
    explicit DynamicString(const char* value = nullptr) {
        if (value) {
            m_value = value;
        }
    }
    
    const char* GetValue() const override { 
        return m_value.c_str(); 
    }
    
    void SetValue(const char* value) override { 
        m_value = value ? value : ""; 
    }
    
    size_t GetLength() const override { 
        return m_value.length(); 
    }
};

// Factory function
IDynamicString* CreateDynamicString(const char* value = nullptr) {
    return new DynamicString(value);
}

namespace {
    thread_local std::string g_lastError;
    
    void SetError(const char* error) {
        g_lastError = error ? error : "";
    }
    
    template<typename T>
    T* HandleToPtr(void* handle) {
        return static_cast<T*>(handle);
    }
    
    template<typename T>
    void* PtrToHandle(T* ptr) {
        return static_cast<void*>(ptr);
    }
}

// Error handling implementation
extern "C" {

const char* {{ namespace.name }}_GetLastError() {
    return g_lastError.c_str();
}

void {{ namespace.name }}_ClearError() {
    g_lastError.clear();
}

// IDynamicString C API implementation
IDynamicString_Handle IDynamicString_Create(const char* value) {
    try {
        return PtrToHandle(CreateDynamicString(value));
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void IDynamicString_AddRef(IDynamicString_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* str = HandleToPtr<IDynamicString>(handle);
        str->AddRef();
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

void IDynamicString_Release(IDynamicString_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* str = HandleToPtr<IDynamicString>(handle);
        str->Release();
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

const char* IDynamicString_GetValue(IDynamicString_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return "";
    }
    try {
        auto* str = HandleToPtr<IDynamicString>(handle);
        return str->GetValue();
    } catch (const std::exception& e) {
        SetError(e.what());
        return "";
    }
}

size_t IDynamicString_GetLength(IDynamicString_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return 0;
    }
    try {
        auto* str = HandleToPtr<IDynamicString>(handle);
        return str->GetLength();
    } catch (const std::exception& e) {
        SetError(e.what());
        return 0;
    }
}

void IDynamicString_SetValue(IDynamicString_Handle handle, const char* value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* str = HandleToPtr<IDynamicString>(handle);
        str->SetValue(value);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

{% for interface in namespace.interfaces %}
// {{ interface.name }} implementation

{{ interface.name }}_Handle {{ interface.name }}_Create() {
    try {
        // Note: This assumes the C++ implementation has a concrete class
        // In practice, you'd need a factory or concrete implementation
        SetError("{{ interface.name }}_Create not implemented - interface requires concrete implementation");
        return nullptr;
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void {{ interface.name }}_Release({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        delete obj;
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

void {{ interface.name }}_AddRef({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    // Note: This would need proper reference counting implementation
    // For now, this is a no-op placeholder
}

{% for property in interface.properties %}
// Property: {{ property.name }}
{% if property.type | is_primitive or property.type | is_enum %}
{{ property.type | c_type }} {{ interface.name | c_function_name(property.name, "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        {% if property.type | is_enum %}
        return static_cast<{{ property.type | c_type }}>(obj->get_{{ property.name }}());
        {% else %}
        return obj->get_{{ property.name }}();
        {% endif %}
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}
{% elif property.type | is_string %}
IDynamicString_Handle {{ interface.name | c_function_name(property.name, "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        std::string result = obj->get_{{ property.name }}();
        // Create new IDynamicString with refcount=1
        IDynamicString* str = CreateDynamicString(result.c_str());
        return PtrToHandle(str);
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}
{% elif property.type | is_array %}
size_t {{ interface.name | c_function_name(property.name + "_Count", "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return 0;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        return obj->get_{{ property.name }}().size();
    } catch (const std::exception& e) {
        SetError(e.what());
        return 0;
    }
}

{{ property.type.element_type | c_type }} {{ interface.name | c_function_name(property.name + "_Item", "Get") }}({{ interface.name }}_Handle handle, size_t index) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        const auto& array = obj->get_{{ property.name }}();
        if (index >= array.size()) {
            SetError("Index out of bounds");
            return {};
        }
        {% if property.type.element_type | is_string %}
        std::string str = array[index];
        IDynamicString* dynStr = CreateDynamicString(str.c_str());
        return PtrToHandle(dynStr);
        {% elif property.type.element_type | is_enum %}
        return static_cast<{{ property.type.element_type | c_type }}>(array[index]);
        {% else %}
        return array[index];
        {% endif %}
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}
{% elif property.type | is_interface %}
{{ property.type | c_type }} {{ interface.name | c_function_name(property.name, "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        auto result = obj->get_{{ property.name }}();
        return PtrToHandle(result.get());
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}
{% else %}
// Complex type getter for {{ property.name }}
{{ property.type | c_type }} {{ interface.name | c_function_name(property.name, "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    // TODO: Implement complex type getter
    SetError("Complex type getter not implemented");
    return nullptr;
}
{% endif %}

{% if property.writable %}
{% if property.type | is_string %}
void {{ interface.name | c_function_name(property.name, "Set") }}({{ interface.name }}_Handle handle, IDynamicString_Handle value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    if (!value) {
        SetError("Null value");
        return;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        auto* str = HandleToPtr<IDynamicString>(value);
        obj->set_{{ property.name }}(str->GetValue());
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}
{% elif property.type | is_array %}
void {{ interface.name | c_function_name(property.name + "_Clear", "Set") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        obj->set_{{ property.name }}({});
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

void {{ interface.name | c_function_name(property.name + "_Add", "Set") }}({{ interface.name }}_Handle handle, {{ property.type.element_type | c_param_type }} value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    {% if property.type.element_type | is_string %}
    if (!value) {
        SetError("Null value");
        return;
    }
    {% endif %}
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        auto array = obj->get_{{ property.name }}();
        {% if property.type.element_type | is_string %}
        auto* str = HandleToPtr<IDynamicString>(value);
        array.push_back(str->GetValue());
        {% elif property.type.element_type | is_enum %}
        array.push_back(static_cast<{{ namespace.name }}::{{ property.type.element_type.name }}>(value));
        {% else %}
        array.push_back(value);
        {% endif %}
        obj->set_{{ property.name }}(array);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}
{% else %}
void {{ interface.name | c_function_name(property.name, "Set") }}({{ interface.name }}_Handle handle, {{ property.type | c_param_type }} value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        {% if property.type | is_enum %}
        obj->set_{{ property.name }}(static_cast<{{ namespace.name }}::{{ property.type.name }}>(value));
        {% elif property.type | is_primitive %}
        obj->set_{{ property.name }}(value);
        {% elif property.type | is_interface %}
        auto* valueObj = HandleToPtr<{{ namespace.name }}::{{ property.type.name }}>(value);
        obj->set_{{ property.name }}(std::shared_ptr<{{ namespace.name }}::{{ property.type.name }}>(valueObj));
        {% else %}
        // Complex type - needs custom implementation
        SetError("Complex type setter not implemented");
        {% endif %}
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}
{% endif %}
{% endif %}

{% endfor %}
{% for method in interface.methods %}
// Method: {{ method.name }}
{{ method.return_type | c_return_type }} {{ interface.name | c_function_name(method.name) }}(
    {{ interface.name }}_Handle handle
    {%- for param in method.parameters -%}
    , {{ param.type | c_param_type }} {{ param.name }}
    {%- endfor -%}
) {
    if (!handle) {
        SetError("Null handle");
        {% if method.return_type.name != "void" %}
        return {};
        {% else %}
        return;
        {% endif %}
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        {% if method.return_type.name != "void" %}
        auto result = obj->{{ method.name }}(
        {% else %}
        obj->{{ method.name }}(
        {% endif %}
            {%- for param in method.parameters -%}
            {%- if not loop.first %}, {% endif -%}
            {%- if param.type | is_enum -%}
            static_cast<{{ namespace.name }}::{{ param.type.name }}>({{ param.name }})
            {%- elif param.type | is_string -%}
            HandleToPtr<IDynamicString>({{ param.name }})->GetValue()
            {%- else -%}
            {{ param.name }}
            {%- endif -%}
            {%- endfor -%}
        );
        {% if method.return_type.name != "void" %}
        {% if method.return_type | is_string %}
        IDynamicString* str = CreateDynamicString(result.c_str());
        return PtrToHandle(str);
        {% elif method.return_type | is_interface %}
        return PtrToHandle(result.get());
        {% elif method.return_type | is_enum %}
        return static_cast<{{ method.return_type | c_type }}>(result);
        {% else %}
        return result;
        {% endif %}
        {% endif %}
    } catch (const std::exception& e) {
        SetError(e.what());
        {% if method.return_type.name != "void" %}
        return {};
        {% endif %}
    }
}

{% endfor %}
{% endfor %}
// Collection iteration helpers

struct ArrayIterator {
    size_t current = 0;
    // Would contain actual array data
};

struct DictIterator {
    size_t current = 0;
    // Would contain actual map iterator
};

struct SetIterator {
    size_t current = 0;
    // Would contain actual set iterator
};

void {{ namespace.name }}Array_Release({{ namespace.name }}Array_Handle handle) {
    delete HandleToPtr<ArrayIterator>(handle);
}

size_t {{ namespace.name }}Array_Count({{ namespace.name }}Array_Handle handle) {
    if (!handle) return 0;
    // Implementation would return actual count
    return 0;
}

void {{ namespace.name }}Dict_Release({{ namespace.name }}Dict_Handle handle) {
    delete HandleToPtr<DictIterator>(handle);
}

size_t {{ namespace.name }}Dict_Count({{ namespace.name }}Dict_Handle handle) {
    if (!handle) return 0;
    // Implementation would return actual count
    return 0;
}

bool {{ namespace.name }}Dict_Next({{ namespace.name }}Dict_Handle handle, const char** key, void** value) {
    if (!handle) return false;
    // Implementation would iterate through dictionary
    return false;
}

void {{ namespace.name }}Dict_Reset({{ namespace.name }}Dict_Handle handle) {
    if (!handle) return;
    auto* iter = HandleToPtr<DictIterator>(handle);
    iter->current = 0;
}

void {{ namespace.name }}Set_Release({{ namespace.name }}Set_Handle handle) {
    delete HandleToPtr<SetIterator>(handle);
}

size_t {{ namespace.name }}Set_Count({{ namespace.name }}Set_Handle handle) {
    if (!handle) return 0;
    // Implementation would return actual count
    return 0;
}

bool {{ namespace.name }}Set_Next({{ namespace.name }}Set_Handle handle, void** value) {
    if (!handle) return false;
    // Implementation would iterate through set
    return false;
}

void {{ namespace.name }}Set_Reset({{ namespace.name }}Set_Handle handle) {
    if (!handle) return;
    auto* iter = HandleToPtr<SetIterator>(handle);
    iter->current = 0;
}

} // extern "C"