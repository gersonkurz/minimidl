// Generated by MinimIDL - C Wrapper Implementation
// DO NOT EDIT - This file was automatically generated

#include "{{ namespace.name.lower() }}_wrapper.h"
#include "{{ namespace.name }}.hpp"
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <memory>
#include <cstring>
#include <thread>

namespace {
    thread_local std::string g_lastError;
    
    void SetError(const char* error) {
        g_lastError = error ? error : "";
    }
    
    template<typename T>
    T* HandleToPtr(void* handle) {
        return static_cast<T*>(handle);
    }
    
    template<typename T>
    void* PtrToHandle(T* ptr) {
        return static_cast<void*>(ptr);
    }
}

// Error handling implementation
extern "C" {

const char* {{ namespace.name }}_GetLastError() {
    return g_lastError.c_str();
}

void {{ namespace.name }}_ClearError() {
    g_lastError.clear();
}

{% for interface in namespace.interfaces %}
// {{ interface.name }} implementation

{{ interface.name }}_Handle {{ interface.name }}_Create() {
    try {
        // Note: This assumes the C++ implementation has a concrete class
        // In practice, you'd need a factory or concrete implementation
        SetError("{{ interface.name }}_Create not implemented - interface requires concrete implementation");
        return nullptr;
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void {{ interface.name }}_Release({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        delete obj;
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

void {{ interface.name }}_AddRef({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    // Note: This would need proper reference counting implementation
    // For now, this is a no-op placeholder
}

{% for property in interface.properties %}
// Property: {{ property.name }}
{% if property.type | is_primitive or property.type | is_enum %}
{{ property.type | c_type }} {{ interface.name | c_function_name(property.name, "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        {% if property.type | is_enum %}
        return static_cast<{{ property.type | c_type }}>(obj->get_{{ property.name }}());
        {% else %}
        return obj->get_{{ property.name }}();
        {% endif %}
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}
{% elif property.type | is_string %}
const char* {{ interface.name | c_function_name(property.name, "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        // Note: This returns a pointer to internal string data
        // In production, you'd need proper lifetime management
        static thread_local std::string result;
        result = obj->get_{{ property.name }}();
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}
{% elif property.type | is_array %}
size_t {{ interface.name | c_function_name(property.name + "_Count", "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return 0;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        return obj->get_{{ property.name }}().size();
    } catch (const std::exception& e) {
        SetError(e.what());
        return 0;
    }
}

{{ property.type.element_type | c_type }} {{ interface.name | c_function_name(property.name + "_Item", "Get") }}({{ interface.name }}_Handle handle, size_t index) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        const auto& array = obj->get_{{ property.name }}();
        if (index >= array.size()) {
            SetError("Index out of bounds");
            return {};
        }
        {% if property.type.element_type | is_string %}
        static thread_local std::string result;
        result = array[index];
        return result.c_str();
        {% else %}
        return array[index];
        {% endif %}
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}
{% elif property.type | is_interface %}
{{ property.type | c_type }} {{ interface.name | c_function_name(property.name, "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        auto result = obj->get_{{ property.name }}();
        return PtrToHandle(result.get());
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}
{% else %}
// Complex type getter for {{ property.name }}
{{ property.type | c_type }} {{ interface.name | c_function_name(property.name, "Get") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    // TODO: Implement complex type getter
    SetError("Complex type getter not implemented");
    return nullptr;
}
{% endif %}

{% if property.writable %}
{% if property.type | is_string %}
void {{ interface.name | c_function_name(property.name, "Set") }}({{ interface.name }}_Handle handle, const char* value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    if (!value) {
        SetError("Null value");
        return;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        obj->set_{{ property.name }}(value);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}
{% elif property.type | is_array %}
void {{ interface.name | c_function_name(property.name + "_Clear", "Set") }}({{ interface.name }}_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        obj->set_{{ property.name }}({});
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

void {{ interface.name | c_function_name(property.name + "_Add", "Set") }}({{ interface.name }}_Handle handle, {{ property.type.element_type | c_param_type }} value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        auto array = obj->get_{{ property.name }}();
        array.push_back(value);
        obj->set_{{ property.name }}(array);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}
{% else %}
void {{ interface.name | c_function_name(property.name, "Set") }}({{ interface.name }}_Handle handle, {{ property.type | c_param_type }} value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        {% if property.type | is_enum %}
        obj->set_{{ property.name }}(static_cast<{{ namespace.name }}::{{ property.type.name }}>(value));
        {% elif property.type | is_primitive %}
        obj->set_{{ property.name }}(value);
        {% elif property.type | is_interface %}
        auto* valueObj = HandleToPtr<{{ namespace.name }}::{{ property.type.name }}>(value);
        obj->set_{{ property.name }}(std::shared_ptr<{{ namespace.name }}::{{ property.type.name }}>(valueObj));
        {% else %}
        // Complex type - needs custom implementation
        SetError("Complex type setter not implemented");
        {% endif %}
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}
{% endif %}
{% endif %}

{% endfor %}
{% for method in interface.methods %}
// Method: {{ method.name }}
{{ method.return_type | c_return_type }} {{ interface.name | c_function_name(method.name) }}(
    {{ interface.name }}_Handle handle
    {%- for param in method.parameters -%}
    , {{ param.type | c_param_type }} {{ param.name }}
    {%- endfor -%}
) {
    if (!handle) {
        SetError("Null handle");
        {% if method.return_type.name != "void" %}
        return {};
        {% else %}
        return;
        {% endif %}
    }
    try {
        auto* obj = HandleToPtr<{{ namespace.name }}::{{ interface.name }}>(handle);
        {% if method.return_type.name != "void" %}
        auto result = obj->{{ method.name }}(
        {% else %}
        obj->{{ method.name }}(
        {% endif %}
            {%- for param in method.parameters -%}
            {%- if not loop.first %}, {% endif -%}
            {%- if param.type | is_enum -%}
            static_cast<{{ namespace.name }}::{{ param.type.name }}>({{ param.name }})
            {%- else -%}
            {{ param.name }}
            {%- endif -%}
            {%- endfor -%}
        );
        {% if method.return_type.name != "void" %}
        {% if method.return_type | is_string %}
        static thread_local std::string resultStr;
        resultStr = result;
        return resultStr.c_str();
        {% elif method.return_type | is_interface %}
        return PtrToHandle(result.get());
        {% else %}
        return result;
        {% endif %}
        {% endif %}
    } catch (const std::exception& e) {
        SetError(e.what());
        {% if method.return_type.name != "void" %}
        return {};
        {% endif %}
    }
}

{% endfor %}
{% endfor %}
// Collection iteration helpers

struct ArrayIterator {
    size_t current = 0;
    // Would contain actual array data
};

struct DictIterator {
    size_t current = 0;
    // Would contain actual map iterator
};

struct SetIterator {
    size_t current = 0;
    // Would contain actual set iterator
};

void {{ namespace.name }}Array_Release({{ namespace.name }}Array_Handle handle) {
    delete HandleToPtr<ArrayIterator>(handle);
}

size_t {{ namespace.name }}Array_Count({{ namespace.name }}Array_Handle handle) {
    if (!handle) return 0;
    // Implementation would return actual count
    return 0;
}

void {{ namespace.name }}Dict_Release({{ namespace.name }}Dict_Handle handle) {
    delete HandleToPtr<DictIterator>(handle);
}

size_t {{ namespace.name }}Dict_Count({{ namespace.name }}Dict_Handle handle) {
    if (!handle) return 0;
    // Implementation would return actual count
    return 0;
}

bool {{ namespace.name }}Dict_Next({{ namespace.name }}Dict_Handle handle, const char** key, void** value) {
    if (!handle) return false;
    // Implementation would iterate through dictionary
    return false;
}

void {{ namespace.name }}Dict_Reset({{ namespace.name }}Dict_Handle handle) {
    if (!handle) return;
    auto* iter = HandleToPtr<DictIterator>(handle);
    iter->current = 0;
}

void {{ namespace.name }}Set_Release({{ namespace.name }}Set_Handle handle) {
    delete HandleToPtr<SetIterator>(handle);
}

size_t {{ namespace.name }}Set_Count({{ namespace.name }}Set_Handle handle) {
    if (!handle) return 0;
    // Implementation would return actual count
    return 0;
}

bool {{ namespace.name }}Set_Next({{ namespace.name }}Set_Handle handle, void** value) {
    if (!handle) return false;
    // Implementation would iterate through set
    return false;
}

void {{ namespace.name }}Set_Reset({{ namespace.name }}Set_Handle handle) {
    if (!handle) return;
    auto* iter = HandleToPtr<SetIterator>(handle);
    iter->current = 0;
}

} // extern "C"