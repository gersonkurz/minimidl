// Generated by MinimIDL - C Test Harness
// DO NOT EDIT - This file was automatically generated

#include "{{ namespace.name.lower() }}_wrapper.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// Test result tracking
static int tests_run = 0;
static int tests_passed = 0;
static int tests_failed = 0;

#define TEST_ASSERT(condition, message) do { \
    tests_run++; \
    if (!(condition)) { \
        printf("FAIL: %s\n", message); \
        tests_failed++; \
    } else { \
        tests_passed++; \
    } \
} while(0)

#define TEST_SECTION(name) printf("\n=== Testing %s ===\n", name)

{% for enum in namespace.enums %}
// Test {{ enum.name }} enum values
static void test_{{ enum.name }}_values() {
    TEST_SECTION("{{ enum.name }} Enum Values");
    
    {% for value in enum.values %}
    printf("{{ enum.name }}_{{ value.name }} = %d\n", {{ enum.name }}_{{ value.name }});
    {% endfor %}
}

{% endfor %}
{% for interface in namespace.interfaces %}
// Test {{ interface.name }} interface
static void test_{{ interface.name }}() {
    TEST_SECTION("{{ interface.name }} Interface");
    
    // Create instance
    {{ interface.name }}_Handle obj = {{ interface.name }}_Create();
    if (!obj) {
        printf("WARNING: {{ interface.name }}_Create returned NULL - may need concrete implementation\n");
        printf("Last error: %s\n", {{ namespace.name }}_GetLastError());
        return;
    }
    
    printf("Created {{ interface.name }} instance: %p\n", obj);
    
    {% for property in interface.properties %}
    // Test property: {{ property.name }}
    {% if property.type | is_primitive %}
    {
        {{ property.type | c_type }} value = {{ interface.name | c_function_name(property.name, "Get") }}(obj);
        printf("{{ property.name }} initial value: ");
        {% if property.type.name == "bool" %}
        printf("%s\n", value ? "true" : "false");
        {% elif property.type.name in ["int32_t", "int64_t"] %}
        printf("%lld\n", (long long)value);
        {% elif property.type.name in ["float", "double"] %}
        printf("%f\n", value);
        {% else %}
        printf("(unknown type)\n");
        {% endif %}
        
        {% if property.writable %}
        // Test setter
        {% if property.type.name == "bool" %}
        {{ interface.name | c_function_name(property.name, "Set") }}(obj, !value);
        {{ property.type | c_type }} new_value = {{ interface.name | c_function_name(property.name, "Get") }}(obj);
        TEST_ASSERT(new_value != value, "{{ property.name }} setter should change value");
        {% elif property.type.name in ["int32_t", "int64_t"] %}
        {{ interface.name | c_function_name(property.name, "Set") }}(obj, value + 1);
        {{ property.type | c_type }} new_value = {{ interface.name | c_function_name(property.name, "Get") }}(obj);
        TEST_ASSERT(new_value == value + 1, "{{ property.name }} setter should increment value");
        {% endif %}
        {% endif %}
    }
    {% elif property.type | is_string %}
    {
        const char* value = {{ interface.name | c_function_name(property.name, "Get") }}(obj);
        printf("{{ property.name }} initial value: %s\n", value ? value : "(null)");
        
        {% if property.writable %}
        // Test setter
        const char* test_string = "Test String";
        {{ interface.name | c_function_name(property.name, "Set") }}(obj, test_string);
        const char* new_value = {{ interface.name | c_function_name(property.name, "Get") }}(obj);
        TEST_ASSERT(new_value && strcmp(new_value, test_string) == 0, "{{ property.name }} setter should update string");
        {% endif %}
    }
    {% elif property.type | is_array %}
    {
        size_t count = {{ interface.name | c_function_name(property.name + "_Count", "Get") }}(obj);
        printf("{{ property.name }} array count: %zu\n", count);
        
        for (size_t i = 0; i < count && i < 5; i++) {
            {{ property.type.element_type | c_type }} item = {{ interface.name | c_function_name(property.name + "_Item", "Get") }}(obj, i);
            {% if property.type.element_type | is_string %}
            printf("  [%zu]: %s\n", i, item ? item : "(null)");
            {% else %}
            printf("  [%zu]: (value)\n", i);
            {% endif %}
        }
        
        {% if property.writable %}
        // Test array modification
        {{ interface.name | c_function_name(property.name + "_Clear", "Set") }}(obj);
        size_t new_count = {{ interface.name | c_function_name(property.name + "_Count", "Get") }}(obj);
        TEST_ASSERT(new_count == 0, "{{ property.name }} clear should empty array");
        {% endif %}
    }
    {% endif %}
    
    {% endfor %}
    {% for method in interface.methods %}
    // Test method: {{ method.name }}
    printf("\nTesting method {{ method.name }}...\n");
    {% if method.parameters | length == 0 and method.return_type.name == "void" %}
    {{ interface.name | c_function_name(method.name) }}(obj);
    printf("{{ method.name }} executed\n");
    {% else %}
    // Method has parameters or return value - would need specific test values
    printf("{{ method.name }} - skipping (requires test parameters)\n");
    {% endif %}
    
    {% endfor %}
    // Cleanup
    {{ interface.name }}_Release(obj);
    printf("Released {{ interface.name }} instance\n");
}

{% endfor %}
// Main test runner
int main(int argc, char* argv[]) {
    (void)argc;
    (void)argv;
    
    printf("=== {{ namespace.name }} C Wrapper Test Suite ===\n");
    printf("Generated by MinimIDL\n");
    
    {% for enum in namespace.enums %}
    test_{{ enum.name }}_values();
    {% endfor %}
    
    {% for interface in namespace.interfaces %}
    test_{{ interface.name }}();
    {% endfor %}
    
    // Test error handling
    TEST_SECTION("Error Handling");
    {{ namespace.name }}_ClearError();
    const char* error = {{ namespace.name }}_GetLastError();
    TEST_ASSERT(error && strlen(error) == 0, "Error should be empty after clear");
    
    // Test with null handle
    {% if namespace.interfaces %}
    {{ namespace.interfaces[0].name }}_Release(NULL);
    error = {{ namespace.name }}_GetLastError();
    TEST_ASSERT(error && strstr(error, "Null handle") != NULL, "Should report null handle error");
    {% endif %}
    
    // Summary
    printf("\n=== Test Summary ===\n");
    printf("Tests run:    %d\n", tests_run);
    printf("Tests passed: %d\n", tests_passed);
    printf("Tests failed: %d\n", tests_failed);
    
    return tests_failed > 0 ? 1 : 0;
}