// Generated by MinimIDL - C Wrapper Implementation
// DO NOT EDIT - This file was automatically generated

#include "taskmanager_wrapper.h"
#include "taskmanager.hpp"
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <memory>
#include <cstring>
#include <thread>

namespace {
    thread_local std::string g_lastError;
    
    void SetError(const char* error) {
        g_lastError = error ? error : "";
    }
    
    template<typename T>
    T* HandleToPtr(void* handle) {
        return static_cast<T*>(handle);
    }
    
    template<typename T>
    void* PtrToHandle(T* ptr) {
        return static_cast<void*>(ptr);
    }
}

// Error handling implementation
extern "C" {

const char* TaskManager_GetLastError() {
    return g_lastError.c_str();
}

void TaskManager_ClearError() {
    g_lastError.clear();
}

// ITask implementation

ITask_Handle ITask_Create() {
    try {
        // Note: This assumes the C++ implementation has a concrete class
        // In practice, you'd need a factory or concrete implementation
        SetError("ITask_Create not implemented - interface requires concrete implementation");
        return nullptr;
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void ITask_Release(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        delete obj;
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

void ITask_AddRef(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    // Note: This would need proper reference counting implementation
    // For now, this is a no-op placeholder
}

// Property: id
const char* ITask_Getid(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        // Note: This returns a pointer to internal string data
        // In production, you'd need proper lifetime management
        static thread_local std::string result;
        result = obj->get_id();
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}


// Property: title
const char* ITask_Gettitle(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        // Note: This returns a pointer to internal string data
        // In production, you'd need proper lifetime management
        static thread_local std::string result;
        result = obj->get_title();
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}


// Property: created_at
const char* ITask_Getcreated_at(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        // Note: This returns a pointer to internal string data
        // In production, you'd need proper lifetime management
        static thread_local std::string result;
        result = obj->get_created_at();
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}


// Property: description
const char* ITask_Getdescription(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        // Note: This returns a pointer to internal string data
        // In production, you'd need proper lifetime management
        static thread_local std::string result;
        result = obj->get_description();
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void ITask_Setdescription(ITask_Handle handle, const char* value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    if (!value) {
        SetError("Null value");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        obj->set_description(value);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Property: priority
Priority ITask_Getpriority(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        auto result = obj->get_priority();
        return PtrToHandle(result.get());
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void ITask_Setpriority(ITask_Handle handle, Priority value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        auto* valueObj = HandleToPtr<TaskManager::Priority>(value);
        obj->set_priority(std::shared_ptr<TaskManager::Priority>(valueObj));
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Property: status
Status ITask_Getstatus(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        auto result = obj->get_status();
        return PtrToHandle(result.get());
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void ITask_Setstatus(ITask_Handle handle, Status value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        auto* valueObj = HandleToPtr<TaskManager::Status>(value);
        obj->set_status(std::shared_ptr<TaskManager::Status>(valueObj));
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Property: due_date
const char* ITask_Getdue_date(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        // Note: This returns a pointer to internal string data
        // In production, you'd need proper lifetime management
        static thread_local std::string result;
        result = obj->get_due_date();
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void ITask_Setdue_date(ITask_Handle handle, const char* value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    if (!value) {
        SetError("Null value");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        obj->set_due_date(value);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Property: tags
size_t ITask_Gettags_Count(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return 0;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        return obj->get_tags().size();
    } catch (const std::exception& e) {
        SetError(e.what());
        return 0;
    }
}

const char* ITask_Gettags_Item(ITask_Handle handle, size_t index) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        const auto& array = obj->get_tags();
        if (index >= array.size()) {
            SetError("Index out of bounds");
            return {};
        }
        static thread_local std::string result;
        result = array[index];
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

void ITask_Settags_Clear(ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        obj->set_tags({});
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

void ITask_Settags_Add(ITask_Handle handle, const char* value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        auto array = obj->get_tags();
        array.push_back(value);
        obj->set_tags(array);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Method: Complete
void ITask_Complete(
    ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        obj->Complete(
);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Method: Cancel
void ITask_Cancel(
    ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        obj->Cancel(
);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Method: IsOverdue
bool ITask_IsOverdue(
    ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        auto result = obj->IsOverdue(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetMetadata
TaskManagerDict_Handle ITask_GetMetadata(
    ITask_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        auto result = obj->GetMetadata(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: SetMetadata
void ITask_SetMetadata(
    ITask_Handle handle, const char* key, const char* value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITask>(handle);
        obj->SetMetadata(
key, value);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// IProject implementation

IProject_Handle IProject_Create() {
    try {
        // Note: This assumes the C++ implementation has a concrete class
        // In practice, you'd need a factory or concrete implementation
        SetError("IProject_Create not implemented - interface requires concrete implementation");
        return nullptr;
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void IProject_Release(IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        delete obj;
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

void IProject_AddRef(IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    // Note: This would need proper reference counting implementation
    // For now, this is a no-op placeholder
}

// Property: id
const char* IProject_Getid(IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        // Note: This returns a pointer to internal string data
        // In production, you'd need proper lifetime management
        static thread_local std::string result;
        result = obj->get_id();
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}


// Property: name
const char* IProject_Getname(IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        // Note: This returns a pointer to internal string data
        // In production, you'd need proper lifetime management
        static thread_local std::string result;
        result = obj->get_name();
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void IProject_Setname(IProject_Handle handle, const char* value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    if (!value) {
        SetError("Null value");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        obj->set_name(value);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Property: description
const char* IProject_Getdescription(IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return nullptr;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        // Note: This returns a pointer to internal string data
        // In production, you'd need proper lifetime management
        static thread_local std::string result;
        result = obj->get_description();
        return result.c_str();
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void IProject_Setdescription(IProject_Handle handle, const char* value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    if (!value) {
        SetError("Null value");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        obj->set_description(value);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Property: active
bool IProject_Getactive(IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        return obj->get_active();
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

void IProject_Setactive(IProject_Handle handle, bool value) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        obj->set_active(value);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Method: CreateTask
ITask_Handle IProject_CreateTask(
    IProject_Handle handle, const char* title, const char* description) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        auto result = obj->CreateTask(
title, description);
        return PtrToHandle(result.get());
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetTask
ITask_Handle IProject_GetTask(
    IProject_Handle handle, const char* taskId) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        auto result = obj->GetTask(
taskId);
        return PtrToHandle(result.get());
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetTasks
TaskManagerArray_Handle IProject_GetTasks(
    IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        auto result = obj->GetTasks(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetTasksByStatus
TaskManagerArray_Handle IProject_GetTasksByStatus(
    IProject_Handle handle, Status status) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        auto result = obj->GetTasksByStatus(
status);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: DeleteTask
bool IProject_DeleteTask(
    IProject_Handle handle, const char* taskId) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        auto result = obj->DeleteTask(
taskId);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetTaskCount
int32_t IProject_GetTaskCount(
    IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        auto result = obj->GetTaskCount(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetCompletedCount
int32_t IProject_GetCompletedCount(
    IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        auto result = obj->GetCompletedCount(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetTaskCountByStatus
TaskManagerDict_Handle IProject_GetTaskCountByStatus(
    IProject_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::IProject>(handle);
        auto result = obj->GetTaskCountByStatus(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// ITaskManager implementation

ITaskManager_Handle ITaskManager_Create() {
    try {
        // Note: This assumes the C++ implementation has a concrete class
        // In practice, you'd need a factory or concrete implementation
        SetError("ITaskManager_Create not implemented - interface requires concrete implementation");
        return nullptr;
    } catch (const std::exception& e) {
        SetError(e.what());
        return nullptr;
    }
}

void ITaskManager_Release(ITaskManager_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        delete obj;
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

void ITaskManager_AddRef(ITaskManager_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    // Note: This would need proper reference counting implementation
    // For now, this is a no-op placeholder
}

// Method: CreateProject
IProject_Handle ITaskManager_CreateProject(
    ITaskManager_Handle handle, const char* name) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        auto result = obj->CreateProject(
name);
        return PtrToHandle(result.get());
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetProject
IProject_Handle ITaskManager_GetProject(
    ITaskManager_Handle handle, const char* projectId) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        auto result = obj->GetProject(
projectId);
        return PtrToHandle(result.get());
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetProjects
TaskManagerArray_Handle ITaskManager_GetProjects(
    ITaskManager_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        auto result = obj->GetProjects(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetActiveProjects
TaskManagerArray_Handle ITaskManager_GetActiveProjects(
    ITaskManager_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        auto result = obj->GetActiveProjects(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: DeleteProject
bool ITaskManager_DeleteProject(
    ITaskManager_Handle handle, const char* projectId) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        auto result = obj->DeleteProject(
projectId);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: SearchTasks
TaskManagerArray_Handle ITaskManager_SearchTasks(
    ITaskManager_Handle handle, const char* query) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        auto result = obj->SearchTasks(
query);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetTasksByPriority
TaskManagerArray_Handle ITaskManager_GetTasksByPriority(
    ITaskManager_Handle handle, Priority priority) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        auto result = obj->GetTasksByPriority(
priority);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetOverdueTasks
TaskManagerArray_Handle ITaskManager_GetOverdueTasks(
    ITaskManager_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        auto result = obj->GetOverdueTasks(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: GetSettings
TaskManagerDict_Handle ITaskManager_GetSettings(
    ITaskManager_Handle handle) {
    if (!handle) {
        SetError("Null handle");
        return {};
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        auto result = obj->GetSettings(
);
        return result;
    } catch (const std::exception& e) {
        SetError(e.what());
        return {};
    }
}

// Method: UpdateSettings
void ITaskManager_UpdateSettings(
    ITaskManager_Handle handle, TaskManagerDict_Handle settings) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        obj->UpdateSettings(
settings);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Method: Save
void ITaskManager_Save(
    ITaskManager_Handle handle, const char* path) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        obj->Save(
path);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Method: Load
void ITaskManager_Load(
    ITaskManager_Handle handle, const char* path) {
    if (!handle) {
        SetError("Null handle");
        return;
    }
    try {
        auto* obj = HandleToPtr<TaskManager::ITaskManager>(handle);
        obj->Load(
path);
    } catch (const std::exception& e) {
        SetError(e.what());
    }
}

// Collection iteration helpers

struct ArrayIterator {
    size_t current = 0;
    // Would contain actual array data
};

struct DictIterator {
    size_t current = 0;
    // Would contain actual map iterator
};

struct SetIterator {
    size_t current = 0;
    // Would contain actual set iterator
};

void TaskManagerArray_Release(TaskManagerArray_Handle handle) {
    delete HandleToPtr<ArrayIterator>(handle);
}

size_t TaskManagerArray_Count(TaskManagerArray_Handle handle) {
    if (!handle) return 0;
    // Implementation would return actual count
    return 0;
}

void TaskManagerDict_Release(TaskManagerDict_Handle handle) {
    delete HandleToPtr<DictIterator>(handle);
}

size_t TaskManagerDict_Count(TaskManagerDict_Handle handle) {
    if (!handle) return 0;
    // Implementation would return actual count
    return 0;
}

bool TaskManagerDict_Next(TaskManagerDict_Handle handle, const char** key, void** value) {
    if (!handle) return false;
    // Implementation would iterate through dictionary
    return false;
}

void TaskManagerDict_Reset(TaskManagerDict_Handle handle) {
    if (!handle) return;
    auto* iter = HandleToPtr<DictIterator>(handle);
    iter->current = 0;
}

void TaskManagerSet_Release(TaskManagerSet_Handle handle) {
    delete HandleToPtr<SetIterator>(handle);
}

size_t TaskManagerSet_Count(TaskManagerSet_Handle handle) {
    if (!handle) return 0;
    // Implementation would return actual count
    return 0;
}

bool TaskManagerSet_Next(TaskManagerSet_Handle handle, void** value) {
    if (!handle) return false;
    // Implementation would iterate through set
    return false;
}

void TaskManagerSet_Reset(TaskManagerSet_Handle handle) {
    if (!handle) return;
    auto* iter = HandleToPtr<SetIterator>(handle);
    iter->current = 0;
}

} // extern "C"