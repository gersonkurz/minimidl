// Generated by MinimIDL - Swift Wrapper
// DO NOT EDIT - This file was automatically generated

import Foundation
import TaskManagerC

/// ITask wrapper class
public class Task {
    internal let handle: OpaquePointer
    private var isOwned: Bool
    
    /// Initialize with a new instance
    public init() {
        guard let h = ITask_Create() else {
            fatalError("Failed to create ITask instance")
        }
        self.handle = h
        self.isOwned = true
    }
    
    /// Initialize with existing handle (does not take ownership)
    internal init(handle: OpaquePointer) {
        self.handle = handle
        self.isOwned = false
        ITask_AddRef(handle)
    }
    
    deinit {
        if isOwned {
            ITask_Release(handle)
        }
    }
    
    /// id property
    public var id: String {
        guard let cString = ITask_Getid(handle) else {
            return ""
        }
        return String(cString: cString)
    }
    
    /// title property
    public var title: String {
        guard let cString = ITask_Gettitle(handle) else {
            return ""
        }
        return String(cString: cString)
    }
    
    /// created_at property
    public var created_at: String {
        guard let cString = ITask_Getcreated_at(handle) else {
            return ""
        }
        return String(cString: cString)
    }
    
    /// description property
    public var description: String {
        get {
            guard let cString = ITask_Getdescription(handle) else {
                return ""
            }
            return String(cString: cString)
        }
        set {
            ITask_Setdescription(handle, newValue)
        }
    }
    
    /// priority property
    // TODO: Implement property priority of type line=None column=None name='Priority'
    
    /// status property
    // TODO: Implement property status of type line=None column=None name='Status'
    
    /// due_date property
    public var due_date: String {
        get {
            guard let cString = ITask_Getdue_date(handle) else {
                return ""
            }
            return String(cString: cString)
        }
        set {
            ITask_Setdue_date(handle, newValue)
        }
    }
    
    /// tags property
    public var tags: [String] {
        get {
            let count = ITask_Gettags_Count(handle)
            var result: [String] = []
            result.reserveCapacity(Int(count))
            for i in 0..<count {
                if let cString = ITask_Gettags_Item(handle, i) {
                    result.append(String(cString: cString))
                }
            }
            return result
        }
        set {
            ITask_Settags_Clear(handle)
            for item in newValue {
                ITask_Settags_Add(handle, item)
            }
        }
    }
    
    /// Complete method
    public func Complete() {
        ITask_Complete(handle)
    }
    
    /// Cancel method
    public func Cancel() {
        ITask_Cancel(handle)
    }
    
    /// IsOverdue method
    public func IsOverdue() -> Bool {
        return ITask_IsOverdue(handle)
    }
    
    /// GetMetadata method
    // TODO: Implement method GetMetadata with return type line=None column=None key_type=PrimitiveType(line=None, column=None, name='string_t') value_type=PrimitiveType(line=None, column=None, name='string_t')
    
    /// SetMetadata method
    public func SetMetadata(key: String, value: String) {
        ITask_SetMetadata(
            handle, key, value)
    }
    
}

/// IProject wrapper class
public class Project {
    internal let handle: OpaquePointer
    private var isOwned: Bool
    
    /// Initialize with a new instance
    public init() {
        guard let h = IProject_Create() else {
            fatalError("Failed to create IProject instance")
        }
        self.handle = h
        self.isOwned = true
    }
    
    /// Initialize with existing handle (does not take ownership)
    internal init(handle: OpaquePointer) {
        self.handle = handle
        self.isOwned = false
        IProject_AddRef(handle)
    }
    
    deinit {
        if isOwned {
            IProject_Release(handle)
        }
    }
    
    /// id property
    public var id: String {
        guard let cString = IProject_Getid(handle) else {
            return ""
        }
        return String(cString: cString)
    }
    
    /// name property
    public var name: String {
        get {
            guard let cString = IProject_Getname(handle) else {
                return ""
            }
            return String(cString: cString)
        }
        set {
            IProject_Setname(handle, newValue)
        }
    }
    
    /// description property
    public var description: String {
        get {
            guard let cString = IProject_Getdescription(handle) else {
                return ""
            }
            return String(cString: cString)
        }
        set {
            IProject_Setdescription(handle, newValue)
        }
    }
    
    /// active property
    public var active: Bool {
        get {
            return IProject_Getactive(handle)
        }
        set {
            IProject_Setactive(handle, newValue)
        }
    }
    
    /// CreateTask method
    public func CreateTask(title: String, description: String) -> Task {
        guard let h = IProject_CreateTask(
            handle, title, description) else {
            fatalError("Non-nullable return value was null")
        }
        return Task(handle: h)
    }
    
    /// GetTask method
    public func GetTask(taskId: String) -> Task? {
        guard let h = IProject_GetTask(
            handle, taskId) else {
            return nil
        }
        return Task(handle: h)
    }
    
    /// GetTasks method
    // TODO: Implement method GetTasks with return type line=None column=None element_type=TypeRef(line=None, column=None, name='ITask')
    
    /// GetTasksByStatus method
    public func GetTasksByStatus(status: Status) -> [Task] {
        // TODO: Implement method with complex return type
        fatalError("Not implemented")
    }
    
    /// DeleteTask method
    public func DeleteTask(taskId: String) -> Bool {
        return IProject_DeleteTask(
            handle, taskId)
    }
    
    /// GetTaskCount method
    public func GetTaskCount() -> Int32 {
        return IProject_GetTaskCount(handle)
    }
    
    /// GetCompletedCount method
    public func GetCompletedCount() -> Int32 {
        return IProject_GetCompletedCount(handle)
    }
    
    /// GetTaskCountByStatus method
    // TODO: Implement method GetTaskCountByStatus with return type line=None column=None key_type=PrimitiveType(line=None, column=None, name='string_t') value_type=PrimitiveType(line=None, column=None, name='int32_t')
    
}

/// ITaskManager wrapper class
public class TaskManager {
    internal let handle: OpaquePointer
    private var isOwned: Bool
    
    /// Initialize with a new instance
    public init() {
        guard let h = ITaskManager_Create() else {
            fatalError("Failed to create ITaskManager instance")
        }
        self.handle = h
        self.isOwned = true
    }
    
    /// Initialize with existing handle (does not take ownership)
    internal init(handle: OpaquePointer) {
        self.handle = handle
        self.isOwned = false
        ITaskManager_AddRef(handle)
    }
    
    deinit {
        if isOwned {
            ITaskManager_Release(handle)
        }
    }
    
    /// CreateProject method
    public func CreateProject(name: String) -> Project {
        guard let h = ITaskManager_CreateProject(
            handle, name) else {
            fatalError("Non-nullable return value was null")
        }
        return Project(handle: h)
    }
    
    /// GetProject method
    public func GetProject(projectId: String) -> Project? {
        guard let h = ITaskManager_GetProject(
            handle, projectId) else {
            return nil
        }
        return Project(handle: h)
    }
    
    /// GetProjects method
    // TODO: Implement method GetProjects with return type line=None column=None element_type=TypeRef(line=None, column=None, name='IProject')
    
    /// GetActiveProjects method
    // TODO: Implement method GetActiveProjects with return type line=None column=None element_type=TypeRef(line=None, column=None, name='IProject')
    
    /// DeleteProject method
    public func DeleteProject(projectId: String) -> Bool {
        return ITaskManager_DeleteProject(
            handle, projectId)
    }
    
    /// SearchTasks method
    public func SearchTasks(query: String) -> [Task] {
        // TODO: Implement method with complex return type
        fatalError("Not implemented")
    }
    
    /// GetTasksByPriority method
    public func GetTasksByPriority(priority: Priority) -> [Task] {
        // TODO: Implement method with complex return type
        fatalError("Not implemented")
    }
    
    /// GetOverdueTasks method
    // TODO: Implement method GetOverdueTasks with return type line=None column=None element_type=TypeRef(line=None, column=None, name='ITask')
    
    /// GetSettings method
    // TODO: Implement method GetSettings with return type line=None column=None key_type=PrimitiveType(line=None, column=None, name='string_t') value_type=PrimitiveType(line=None, column=None, name='string_t')
    
    /// UpdateSettings method
    public func UpdateSettings(settings: [String: String]) {
        ITaskManager_UpdateSettings(
            handle, settings)
    }
    
    /// Save method
    public func Save(path: String) {
        ITaskManager_Save(
            handle, path)
    }
    
    /// Load method
    public func Load(path: String) {
        ITaskManager_Load(
            handle, path)
    }
    
}

